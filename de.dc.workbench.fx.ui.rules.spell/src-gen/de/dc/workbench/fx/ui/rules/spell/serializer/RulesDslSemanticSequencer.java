/*
 * generated by Xtext 2.25.0
 */
package de.dc.workbench.fx.ui.rules.spell.serializer;

import com.google.inject.Inject;
import de.dc.workbench.fx.ui.rules.Input;
import de.dc.workbench.fx.ui.rules.Output;
import de.dc.workbench.fx.ui.rules.OutputField;
import de.dc.workbench.fx.ui.rules.Rule;
import de.dc.workbench.fx.ui.rules.RuleSet;
import de.dc.workbench.fx.ui.rules.RulesManager;
import de.dc.workbench.fx.ui.rules.RulesPackage;
import de.dc.workbench.fx.ui.rules.Uri;
import de.dc.workbench.fx.ui.rules.spell.services.RulesDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RulesDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RulesDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RulesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RulesPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case RulesPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case RulesPackage.OUTPUT_FIELD:
				sequence_OutputField(context, (OutputField) semanticObject); 
				return; 
			case RulesPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case RulesPackage.RULE_SET:
				sequence_RuleSet(context, (RuleSet) semanticObject); 
				return; 
			case RulesPackage.RULES_MANAGER:
				sequence_RulesManager(context, (RulesManager) semanticObject); 
				return; 
			case RulesPackage.URI:
				sequence_Uri(context, (Uri) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     value=EString?
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputField returns OutputField
	 *
	 * Constraint:
	 *     (name=EString value=EString)
	 */
	protected void sequence_OutputField(ISerializationContext context, OutputField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RulesPackage.Literals.BASE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RulesPackage.Literals.BASE_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, RulesPackage.Literals.BASE_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RulesPackage.Literals.BASE_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputFieldAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOutputFieldAccess().getValueEStringParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (name=EString value=EString? model=[Uri|EString]? mapper=[Uri|EString]? (fields+=OutputField fields+=OutputField*)?)
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleSet returns RuleSet
	 *
	 * Constraint:
	 *     (name=EString (rules+=[Rule|EString] rules+=[Rule|EString]*)? output=[Output|EString]?)
	 */
	protected void sequence_RuleSet(ISerializationContext context, RuleSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=EString condition=Condition pattern=EString)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RulesPackage.Literals.RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RulesPackage.Literals.RULE__NAME));
			if (transientValues.isValueTransient(semanticObject, RulesPackage.Literals.RULE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RulesPackage.Literals.RULE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, RulesPackage.Literals.RULE__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RulesPackage.Literals.RULE__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRuleAccess().getConditionConditionEnumRuleCall_5_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getRuleAccess().getPatternEStringParserRuleCall_6_0(), semanticObject.getPattern());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RulesManager returns RulesManager
	 *
	 * Constraint:
	 *     ((imports+=Uri imports+=Uri*)? (rules+=Rule rules+=Rule*)? (outputs+=Output outputs+=Output*)? (ruleSet+=RuleSet ruleSet+=RuleSet*)?)
	 */
	protected void sequence_RulesManager(ISerializationContext context, RulesManager semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Uri returns Uri
	 *
	 * Constraint:
	 *     (uri=EString name=EString)
	 */
	protected void sequence_Uri(ISerializationContext context, Uri semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RulesPackage.Literals.URI__URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RulesPackage.Literals.URI__URI));
			if (transientValues.isValueTransient(semanticObject, RulesPackage.Literals.URI__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RulesPackage.Literals.URI__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUriAccess().getUriEStringParserRuleCall_2_0(), semanticObject.getUri());
		feeder.accept(grammarAccess.getUriAccess().getNameEStringParserRuleCall_4_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
